import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { RemittancesService } from './remittances.service';
import { CreateRemittanceDto } from './dto/create-remittance.dto';
import { UpdateRemittanceDto } from './dto/update-remittance.dto';

@Controller('remittances')
export class RemittancesController {
  constructor(private readonly remittancesService: RemittancesService) {}

  @Post()
  create(@Body() createRemittanceDto: CreateRemittanceDto) {
    return this.remittancesService.create(createRemittanceDto);
  }

  @Get()
  findAll() {
    return this.remittancesService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.remittancesService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateRemittanceDto: UpdateRemittanceDto) {
    return this.remittancesService.update(+id, updateRemittanceDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.remittancesService.remove(+id);
  }
}


import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateRemittanceDto } from './dto/create-remittance.dto';
import { UpdateRemittanceDto } from './dto/update-remittance.dto';

@Injectable()
export class RemittancesService {
  constructor(private prisma: PrismaService) {}

  async create(createRemittanceDto: CreateRemittanceDto) {
    return this.prisma.remittance.create({
      data: createRemittanceDto,
    });
  }

  async findAll() {
    return this.prisma.remittance.findMany({
      include: { agent: true },
    });
  }

  async findOne(id: number) {
    const remittance = await this.prisma.remittance.findUnique({
      where: { id },
      include: { agent: true },
    });
    if (!remittance) throw new NotFoundException('Remittance not found');
    return remittance;
  }

  async update(id: number, updateRemittanceDto: UpdateRemittanceDto) {
    await this.findOne(id); // ensure exists
    return this.prisma.remittance.update({
      where: { id },
      data: updateRemittanceDto,
    });
  }

  async remove(id: number) {
    await this.findOne(id); // ensure exists
    return this.prisma.remittance.delete({ where: { id } });
  }
}



// ------------------------------------------------------------
// Prisma Schema — Rebuilt & Optimized for Role/Permission logic
// ------------------------------------------------------------

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------------------------
// MODELS
// ---------------------------

model User {
  id            Int      @id @default(autoincrement())
  role          String
  email         String   @unique
  fullName      String
  phoneNumber   String   @unique
  phoneVerified Boolean  @default(false)
  kycStatus     String   @default("pending")
  approvalStatus String  @default("pending")
  companyName         String?
  legalForm           String?
  managerName         String?
  companyPhone        String?
  companyAddress      String?
  businessDescription String?
  legalFormDocument   String?
  walletBalance Float    @default(0)
  currency      String   @default("USD")
  referralCode  String?   @unique
  referredBy    String?
  accountType   String   @default("personal")
  agentStatus   String?  @default("pending")
  businessName  String?
  profileImage  String
  address       String
  country       String
  dateOfBirth   DateTime
  rewardsPoints Float    @default(0)
  qrCode        String   @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  passwordHash  String?

  // Relations
  transactionLimits    TransactionLimits?
  sentTransactions     Transaction[]      @relation("SentTransactions")
  receivedTransactions Transaction[]      @relation("ReceivedTransactions")
  refreshTokens        RefreshToken[]
  userRoles            UserRole[]
  otps                 Otp[]
  passwordResets       PasswordReset[]
  paymentMethods         PaymentMethod[]
  supportTickets         SupportTicket[]
  assignedSupportTickets SupportTicket[] @relation("SupportAssignedTo")
  tontinesCreated        Tontine[]           @relation("TontineCreator")
  tontineCoAdminFor      Tontine[]           @relation("TontineCoAdmin")
  tontineMembers         TontineMember[]
  tontineContributions   TontineContribution[]
  qrPayments             QRPayment[]         @relation("QRRecipient")
  remittancesAsAgent     Remittance[]        @relation("RemittanceAgent")
  savedContacts          SavedContact[]      @relation("SavedContactAgent")
  floatRequests          FloatRequest[]      @relation("FloatRequestAgent")

  @@map("User")
}


model TransactionLimits {
  id            Int   @id @default(autoincrement())
  userId        Int   @unique
  daily         Float
  weeklyBudget  Float @default(0)
  monthlyBudget Float @default(0)
  yearlyBudget  Float @default(0)
  user          User  @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@map("TransactionLimits")
}

model Transaction {
  id              Int      @id @default(autoincrement())
  transactionId   String   @unique
  senderId        Int
  recipientId     Int?
  amount          Float
  currency        String   @default("USD")
  type            String
  status          String   @default("pending")
  paymentMethod   String?
  description     String?
  fee             Float    @default(0)
  exchangeRate    Float?
  referenceNumber String?
  qrCode          String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  sender    User  @relation("SentTransactions", fields: [senderId], references: [id])
  recipient User? @relation("ReceivedTransactions", fields: [recipientId], references: [id])

  @@map("Transaction")
}

model Role {
  id              Int              @id @default(autoincrement())
  name            String           @unique
  description     String?
  userRoles       UserRole[]
  rolePermissions RolePermission[]

  // Optional direct field for permissions if you want to simplify:
  // permissions String[] @default([])

  @@map("Role")
}

model Permission {
  id              Int              @id @default(autoincrement())
  action          String
  resource        String
  description     String?
  rolePermissions RolePermission[]

  @@unique([action, resource])
  @@map("Permission")
}

model UserRole {
  id     Int  @id @default(autoincrement())
  userId Int
  roleId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  role   Role @relation(fields: [roleId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@map("UserRole")
}

model RolePermission {
  id           Int        @id @default(autoincrement())
  roleId       Int
  permissionId Int
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@unique([roleId, permissionId], name: "role_permission_unique") // ✅ named composite unique
  @@map("RolePermission")
}

model RefreshToken {
  id           Int           @id @default(autoincrement())
  tokenHash    String
  userId       Int
  expiresAt    DateTime
  revoked      Boolean       @default(false)
  createdAt    DateTime      @default(now())
  replacedById Int?          @unique // ✅ required for one-to-one
  user         User          @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  replacedBy   RefreshToken? @relation("ReplacedBy", fields: [replacedById], references: [id], onDelete: SetNull, onUpdate: Cascade)
  replacement  RefreshToken? @relation("ReplacedBy")

  @@map("RefreshToken")
}

model Otp {
  id        Int      @id @default(autoincrement())
  email     String
  codeHash  String
  purpose   String
  expiresAt DateTime
  used      Boolean  @default(false)
  attempts  Int      @default(0)
  userId    Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  @@map("Otp")
}

model PasswordReset {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userId    Int
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("PasswordReset")
}

model PaymentMethod {
  id            Int     @id @default(autoincrement())
  userId        Int
  type          String
  provider      String? 
  accountName   String?
  accountNumber String?
  bankName      String?
  expiryDate    String?     // stored as text (per your Base44)
  isDefault     Boolean     @default(false)
  isVerified    Boolean     @default(false)
  lastFour      String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("PaymentMethod")
  @@index([userId])
}

model SupportTicket {
  id           Int       @id @default(autoincrement())
  ticketId     String?   @unique
  userId       Int
  subject      String
  description  String
  category     String?
  priority     String    @default("medium")
  status       String    @default("open")
  assignedToId Int?      // admin user id (optional)
  attachments  String[]  @default([])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  assignedTo User?      @relation("SupportAssignedTo", fields: [assignedToId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@map("SupportTicket")
  @@index([userId])
  @@index([assignedToId])
}

model Tontine {
  id                    Int       @id @default(autoincrement())
  name                  String
  description           String?
  type                  String
  contributionAmount    Float
  currency              String    @default("USD")
  contributionFrequency String
  payoutInterval        String?
  startDate             DateTime?
  nextPayoutDate        DateTime?
  status                String    @default("forming")
  payoutOrder           Int[]     @default([])   // array of user ids, order of payouts
  currentRound          Int       @default(1)
  totalPot              Float     @default(0)
  maxMembers            Int?
  inviteCode            String?   @unique
  paymentMethods        String[]  @default([])    // accepted payment methods (strings)
  notificationSettings  Json?                        // store object: { payment_reminders: true, ... }
  creatorId             Int
  coAdminId             Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creator   User        @relation("TontineCreator", fields: [creatorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  coAdmin   User?       @relation("TontineCoAdmin", fields: [coAdminId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  members   TontineMember[]
  contributions TontineContribution[]

  @@map("Tontine")
  @@index([creatorId])
  @@index([coAdminId])
}

model TontineMember {
  id        Int     @id @default(autoincrement())
  tontineId Int
  userId    Int
  joinedAt  DateTime @default(now())
  role      String?  // e.g., member, admin
  isActive  Boolean  @default(true)

  tontine Tontine @relation(fields: [tontineId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([tontineId, userId], name: "tontine_member_unique")
  @@map("TontineMember")
  @@index([tontineId])
  @@index([userId])
}

model TontineContribution {
  id              Int      @id @default(autoincrement())
  tontineId       Int
  userId          Int
  amount          Float
  currency        String   @default("USD")
  contributionDate DateTime?
  roundNumber     Int
  paymentMethod   String?
  status          String   @default("pending")
  transactionId   String?
  createdAt       DateTime @default(now())

  tontine Tontine @relation(fields: [tontineId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("TontineContribution")
  @@index([tontineId])
  @@index([userId])
}

model QRPayment {
  id          Int      @id @default(autoincrement())
  qrCode      String   @unique
  recipientId Int
  amount      Float?
  currency    String   @default("USD")
  description String?
  isActive    Boolean  @default(true)
  expiryDate  DateTime?
  usageLimit  Int?
  usageCount  Int      @default(0)
  paymentType String   @default("one_time") // one_time, recurring, open_amount
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  recipient User @relation("QRRecipient", fields: [recipientId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("QRPayment")
  @@index([recipientId])
}

model Remittance {
  id                  Int      @id @default(autoincrement())
  agentId             Int
  senderDetails       Json     // { name, phone, country }
  recipientDetails    Json     // { name, phone, country, bank_name, account_number }
  bankName            String?
  accountNumber       String?
  sourceAmount        Float
  sourceCurrency      String?
  destinationAmount   Float?
  destinationCurrency String?
  exchangeRate        Float?
  deliveryMethod      String
  status              String   @default("pending")
  transactionId       String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  agent User @relation("RemittanceAgent", fields: [agentId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("Remittance")
  @@index([agentId])
}

model SavedContact {
  id          Int    @id @default(autoincrement())
  agentId     Int
  contactType String
  name        String
  phone       String?
  country     String?
  bankName    String?
  accountNumber String?
  createdAt   DateTime @default(now())

  agent User @relation("SavedContactAgent", fields: [agentId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("SavedContact")
  @@index([agentId])
}

model SystemSettings {
  id                  Int     @id @default(autoincrement())
  transferFeePercent  Float   @default(1.5)
  withdrawalFeeFlat   Float   @default(2.5)
  forexMarkupPercent  Float   @default(2.0)
  cryptoMarkupPercent Float   @default(2.5)
  tontineFeePercent   Float   @default(0.5)
  updatedAt           DateTime @updatedAt
  createdAt           DateTime @default(now())

  @@map("SystemSettings")
}

model FloatRequest {
  id        Int      @id @default(autoincrement())
  agentId   Int
  amount    Float
  currency  String   @default("USD")
  status    String   @default("pending")
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  agent User @relation("FloatRequestAgent", fields: [agentId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@map("FloatRequest")
  @@index([agentId])
}



These are my current schema, Controller and Service files in Backend. and here is my base44 apis which are using in my current react js frontend. I need to replace the base44 apis with my backend apis in my frontend. You have to check that if base44 apis are now replacable with my backend apis. if so find them. if any api missing make them in controller and service

// JavaScript Example: Reading Entities
// Filterable fields: agent_id, sender_details, recipient_details, source_amount, source_currency, destination_amount, destination_currency, exchange_rate, delivery_method, status, transaction_id
async function fetchRemittanceEntities() {
    const response = await fetch(`https://app.base44.com/api/apps/68ec90ca08a099297c5ddec3/entities/Remittance`, {
        headers: {
            'api_key': '2208e6b196a34c7fb678fd37d21028b5', // or use await User.me() to get the API key
            'Content-Type': 'application/json'
        }
    });
    const data = await response.json();
    console.log(data);
}

// JavaScript Example: Updating an Entity
// Filterable fields: agent_id, sender_details, recipient_details, source_amount, source_currency, destination_amount, destination_currency, exchange_rate, delivery_method, status, transaction_id
async function updateRemittanceEntity(entityId, updateData) {
    const response = await fetch(`https://app.base44.com/api/apps/68ec90ca08a099297c5ddec3/entities/Remittance/${entityId}`, {
        method: 'PUT',
        headers: {
            'api_key': '2208e6b196a34c7fb678fd37d21028b5', // or use await User.me() to get the API key
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
    });
    const data = await response.json();
    console.log(data);
}
